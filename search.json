[{"title":"鼓楼|歌词","url":"https://sacharn.github.io/2021/03/22/鼓楼-歌词/","content":"我走在鼓楼下面\n路在堵着\n雨后的阳光散落\n人们都出来了\n执着的迷惘的\n文艺青年很多\n如果我无聊了就会来这里坐坐\n我是个沉默不语的靠着墙壁晒太阳的过客\n如果我有些倦意了\n就让我在这里独自醒过\n我站在鼓楼上面\n一切繁华与我无关\n这是个拥挤的地方\n而我却很平凡\n我走在鼓楼下面\n淋湿的咖啡馆\n睡不着的后海边\n月亮还在抽着烟\n喝醉的亲吻着\n快活的人不眠\n唯有我倚着围栏\n对过往说晚安\n晚安\n我是个沉默不语的靠着车窗想念你的乘客\n当一零七路再次经过\n时间是带走青春的电车\n我站在什刹海边\n一切甜蜜与我无关\n这是个拥挤的地方\n而我却很孤单\n我在鼓楼 我在鼓楼\n我在鼓楼 我在鼓楼\n我在鼓楼 我在鼓楼\n","categories":[],"tags":[]},{"title":"JVM知识问答总结","url":"https://sacharn.github.io/2021/03/21/JVM知识问答总结/","content":"1. JVM基础1.1 对JVM的认识和理解\n功能：JVM的全称是Java虚拟机，用来运行字节码文件（.class）。\n优点：它屏蔽了具体操作系统和平台的差异，使得同一字节码能在不同平台运行，且能得到相同的结果。\n\n1.1.1 什么是字节码\n定义：扩展名为 .class 的的文件叫做字节码，相比较于源码，它是程序的一种低级表示。\n特性：不面向特定的处理器，只面向虚拟机JVM，经过虚拟机处理过后，程序可以在多平台上运行。\n\n1.1.2 Java 程序从代码到运行的过程\n过程：编写 -&gt; 编译 -&gt; 解释\n⾸先通过IDE/编辑器编写源代码然后经过 JDK 中的编译器（javac）编译成 Java 字节码⽂件（.class⽂件），字节码通过虚拟机执⾏，虚拟机将每⼀条要执⾏的字节码送给解释器，解释器会将其翻译成特定机器上的机器码（及其可执⾏的⼆进制机器码）。\n\n1.2 对类加载器的了解\n功能：类加载器根据指定class文件的全限定名称（例如java.lang.Object，路径+文件的形式），将其加载到JVM内存，转化为Class对象\n\n1.2.1 类加载器的执行流程\n1.2.1.1 加载\n通过类的全限定名来获取该类的二进制字节流\n将二进制字节流所代表的静态存储结构导入为方法区的运行时数据结构\n在堆中生成一个对象来代表这个类，作为方法区数据的入口\n\n1.2.1.2 链接\n验证：保证二进制字节流符合虚拟机的要求，且不会威胁到虚拟机的安全。\n\n准备：为static静态变量分配内存，并设置初始值。\n\n解析：虚拟机将常量池中的符号引用转化为直接引用。\n例如 import xxx.xxx.xxx 属于符号引⽤，⽽通过指针或者对象地址引⽤就是直接引⽤\n\n\n1.2.1.3 初始化​    初始化会对变量进⾏赋值，即对最初的零值，进⾏显式初始化\n1.2.1.4 卸载​    GC 垃圾回收内存中的⽆⽤对象\n1.2.2 类加载器有哪几种，加载顺序是什么样的\n启动类加载器：JDK目录/lib下的jar和类以及**-Xbootclasspath参数指定路径下**的所有类\n\n扩展类加载器：JRE⽬录/lib 下⾯的 jar 和类以及java.ext.dirs 系统变量所指定的路径下的 jar 包\n\n应用类加载器：当前应⽤下 classpath 下⾯的 jar 包和类\n顺序：最底层向上\n\n\n1.2.3 双亲委派机制\n⼯作过程是：如果⼀个类加载器收到了类加载的请求，他⾸先不会⾃⼰去尝试加载这个类，⽽是把这个请求委派给⽗类加载器去完成，每⼀个层次的类加载都是如此，因此所有的加载请求都最终应该传送到最顶层的启动类加载器中，只有当⽗加载器反馈⾃⼰⽆法完成这个加载请求（也就是它的范围搜索中，也没有找到所需要的类），⼦加载器才会尝试⾃⼰去完成加载。\n\n优点：\n\n加载位于rt.jar包中的类（例如 java.lang.Object）时不管是哪个加载器加载，最终都会委托最顶端的启动类加载器 BootStrapClassLoader 进⾏加载，这样保证它在各个类加载器环境下都是同⼀个结果。\n避免了⾃定义代码影响 JDK 的代码，如果我们⾃⼰也创建了⼀个 java.lang.Object 然后放在程序的 classpath 中，就会导致系统中出现不同的 Object 类，Java 类型体系中最基础的⾏为也就⽆法保证。\n\n\n不想用双亲委派机制怎么没办\n自定义类加载器，然后重写loadClass()方法\n\n\n","categories":[],"tags":[]},{"title":"MySQL是如何实现事务隔离的","url":"https://sacharn.github.io/2021/03/21/MySQL是如何实现事务隔离的/","content":"\n首先，读未提交和串行化都是比较极端的做法，读未提交压根不加锁，所以也没有什么隔离效果，可以理解为无隔离。\n其次，串行化。读的时候加共享锁，大家一起读。但是写的时候加排它锁，其他事务既不能并发写，也不能并发读。\n最后是读提交和可重复读。这两种隔离级别比较复杂，因为既要允许一定程度的并发，也要兼顾解决问题。\n\n实现可重复读为了解决不可重复读，或者为了实现可重复读，MySQL 采⽤了 MVVC (多版本并发控制) 的⽅式。\n！可重复读\n我们在数据库表中看到的⼀⾏记录可能实际上有多个版本，每个版本的记录除了有数据本⾝外，还要有⼀个表示版本的字段，记为 row trx_id，⽽这个字段就是使其产⽣的事务的 id，事务 ID 记为 transaction id，它在事务开始的时候向事务系统申请，按时间先后顺序递增。\n\n快照是可重复读和不可重复读的关键，可重复读是在事务开始的时候⽣成⼀个当前事务全局性的快照，⽽读提交则是每次执⾏语句的时候都重新⽣成⼀次快照。\n\n解决并发写问题\n假设事务A执⾏ update 操作， update 的时候要对所修改的行加行锁，这个⾏锁会在提交之后才释放。⽽在事务A提交之前，事务B也想 update 这⾏数据，于是申请⾏锁，但是由于已经被事务A占有，事务B是申请不到的，此时，事务B就会⼀直处于等待状态，直到事务A提交，事务B才能继续执⾏，如果事务A的时间太长，那么事务B很有可能出现超时异常。\n加锁的过程要分有索引和⽆索引两种情况，⽐如下⾯这条语句\n\nupdate user set age=11 where id = 1\n\n\nid 是这张表的主键，是有索引的情况，那么 MySQL 直接就在索引数中找到了这⾏数据，然后⼲净利落的直接加上⾏锁就可以了。\n\n⽽下⾯这条语句\nupdate user set age=11 where age=10\n\n\n表中并没有为 age 字段设置索引，所以， MySQL ⽆法直接定位到这⾏数据。那怎么办呢，当然也不是加表锁了。MySQL 会为这张表中所有⾏加⾏锁，没错，是所有⾏。但是呢，在加上⾏锁后，MySQL 会进⾏⼀遍过滤，发现不满⾜的⾏就释放锁，最终只留下符合条件的⾏。虽然最终只为符合条件的⾏加了锁，但是这⼀锁⼀释放的过程对性能也是影响极⼤的。所以，如果是⼤表的话，建议合理设计索引，如果真的出现这种情况，那很难保证并发度。\n\n解决幻读问题\nMySQL 已经在可重复读隔离级别下解决了幻读的问题。\n\n前⾯刚说了并发写问题的解决⽅式就是⾏锁，⽽解决幻读⽤的也是锁，叫做间隙锁，MySQL把⾏锁和间隙锁合并在⼀起，解决了并发写和幻读的问题，这个锁叫做 Next-Key锁。\n\n在行记录上加行锁，在行记录两边的区间加上间隙锁。\n！解决幻读问题的间隙锁\n\n\n在事务A提交之前，事务B的插⼊操作只能等待，这就是间隙锁起得作⽤。当事务A执⾏\nupdate user set name=&#x27;风筝2号’ where age = 10;\n\n 的时候，由于条件 here age = 10，数据库不仅在 age =10 的⾏上添加了⾏锁，⽽且在这条记录的两边，也就是(负⽆穷,10]、(10,30]这两个区间加了间隙锁，从⽽导致事务B插⼊操作⽆法完成，只能等待事务A提交。不仅插⼊ age = 10 的记录需要等待事务A提交，age&lt;10、10&lt;age&lt;30 的记录页⽆法完成，⽽⼤于等于30的记录则不受影响，这⾜以解决幻读问题了。这是有索引的情况，如果 age 不是索引列，那么数据库会为整个表加上间隙锁。所以，如果是没有索引的话，不管 age 是否⼤于等于30，都要等待事务A提交才可以成功插⼊。\n总结\nMySQL 的 InnoDB 引擎才⽀持事务，其中可重复读是默认的隔离级别。\n读未提交和串⾏化基本上是不需要考虑的隔离级别，前者不加锁限制，后者相当于单线程执⾏，效率太差。\n读提交解决了脏读问题，⾏锁解决了并发更新的问题。并且 MySQL 在可重复读级别解决了幻读问题，是通过⾏锁和间隙锁的组合 Next-Key 锁实现的。\n\n","categories":[],"tags":[]},{"title":"MySQL事务隔离级别原理","url":"https://sacharn.github.io/2021/03/20/MySQL事务隔离级别和实现原理/","content":"MySQL事务\nMySQL 事务都是指在 InnoDB 引擎下，因为MyISAM引擎是不支持事务的。\n数据库是指：一组数据操作，事务内的操作要么全部成功，要么全部失败。只要有一步失败，就要回滚所有操作。\n事务具有四个特性：ACID——原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）\n\n四大问题：什么是脏读、可重复读、不可重复读、幻读？\n脏读：读到了其他事务修改了但尚未提交的数据。这个事务的操作有可能发生回滚，那么就可能发生错误。\n可重复读：在一个事务内，从事务开始到事务结束，期间读到的同一批数据，始终是一致的。通常，针对数据更新（UPDATE）操作。\n不可重复读：在一个事务内，不同时刻读到的数据可能是不一致的。通常，针对数据更新（UPDATE）操作。\n幻读：幻读是针对插入（INSERT）操作来说的。假设事务A对某些⾏的内容作了更改，但是还未提交，此时事务B插⼊了与事务A更改前的记录相同的记录⾏，并且在事务A提交之前先提交了，⽽这时，在事务A中查询，会发现好像刚刚的更改对于某些数据未起作⽤，但其实是事务B刚插⼊进来的，让⽤户感觉很魔幻，感觉出现了幻觉，这就叫幻读。\n\n四大隔离级别：读未提交、读提交、可重复读、串行化\nMySQL的默认隔离级别是可重复读。\n\nMySQL 中执⾏事务：事务的执⾏过程如下，以 begin 或者 start transaction 开始，然后执⾏⼀系列操作，最后要执⾏ commit 操作，事务才算结束。当然，如果进⾏回滚操作(rollback)，事务也会结束。\n需要注意的是，begin 命令并不代表事务的开始，事务开始于 begin 命令之后的第⼀条语句执⾏的时候。例如下⾯⽰例中，\nselect * from xxx \n\n才是事务的开始。\nbegin; select * from xxx;  commit; -- 或者 rollback;\n\n\n\n1、读未提交MySQL 事务隔离其实是依靠锁来实现的，加锁自然会带来性能的损失。⽽读未提交隔离级别是不加锁的，所以它的性能是最好的，没有加锁、解锁带来的性能开销。但有利就有弊，这基本上就相当于裸奔啊，所以它连脏读的问题都没办法解决。\n读未提交，其实就是可以读到其他事务未提交的数据，但没有办法保证你读到的数据最终⼀定是提交后的数据，如果中间发⽣回滚，那就会出现脏数据问题，读未提交没办法解决脏数据问题。更别提可重复读和幻读了。\n2、读提交为了解决脏数据问题，就有了读提交隔离级别。读提交就是⼀个事务只能读到其他事务已经提交过的数据，也就是其他事务调⽤ commit 命令之后的数据。那脏数据问题迎刃而解了。\n但这也导致了⼀个问题，在同⼀事务中（事务B），事务的不同时刻，同样的查询条件，查询出来的记录内容是不⼀样的。事务A的提交影响了事务B的查询结果（事务A提交前数值为1，提交后数值为10），这就是不可重复读问题，也就是读提交隔离级别。\n3、可重复读为了解决不可重复读问题，就有了可重复读隔离级别。同时启动两个事务A、B，事务A修改某数据并提交，但是事务B并不受修改的影响，读取的仍然是事务A修改前的值。\n但这仍然存在一个问题，对于新插⼊的⾏记录，就没这么幸运了，幻读就这么产⽣了。\n其实，MySQL 的可重复读隔离级别其实解决了幻读问题\n4、串行化为了解决幻读问题，就有了串行化的隔离级别。串⾏化是4种事务隔离级别中隔离效果最好的，解决了脏读、可重复读、幻读的问题，但是效果最差，它将事务的执⾏变为顺序执⾏，与其他三个隔离级别相⽐，它就相当于单线程，后⼀个事务的执⾏必须等待前⼀个事务结束。\n\n\n","categories":[],"tags":[]},{"title":"流水的学生，铁打的修路","url":"https://sacharn.github.io/2021/03/20/流水的学生，铁打的修路/","content":"​    坊间传闻着一句话——“半年修一次，一次修半年”，说的就是学校永不停歇的修路工程。\n","categories":[],"tags":[]},{"title":"Hello World","url":"https://sacharn.github.io/2021/03/18/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","categories":[],"tags":[]}]