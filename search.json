[{"title":"面经问题整理","url":"https://sacharn.github.io/2021/03/23/面经问题整理/","content":"1、Get和Post请求的区别\n哪一些情况下，浏览器会发送get请求\n​        a. 直接在浏览器地址栏输入某个地址\n​        b. 点击链接\n​        c. 表单默认的提交方式\n\n 哪一些情况下，浏览器会发送post请求？\n\n\n  ​        a. 设置表单method = “post”\n\n get请求的特点\n\n  ​        a. 请求参数会添加到请求资源路劲的后面，只能添加少量参数（因为请求行只有一行，大约只能存放2K左右的数据）（2K左右的数据，看起来也不少。。。）\n  ​        b. 请求参数会显示在浏览器地址栏，路由器会记录请求地址（不安全，容易泄露信息）\n\n post请求的特点\n\n  ​        a. 请求参数添加到实体内容里面，可以添加大量的参数（也解释了为什么浏览器地址栏不能发送post请求，在地址栏里我们只能填写URL，并不能进入到Http包的实体当中）\n  ​        b. 相对安全，但是post请求不会对请求参数进行加密处理（可以使用https协议来保证数据安全）。\n","categories":[],"tags":[]},{"title":"生鲜项目中的实现细节","url":"https://sacharn.github.io/2021/03/22/生鲜项目中的实现细节/","content":"1、统一异常\n我们需要对这些异常进行统一的捕获并处理。SpringBoot中有一个ControllerAdvice的注解，使用该注解表示开启了全局异常的捕获，我们只需在自定义一个方法使用ExceptionHandler注解然后定义捕获异常的类型即可对这些捕获的异常进行统一的处理。如下为全局异常处理类。\n\npackage com.shu.mall.exception;import com.shu.mall.common.ApiRestResponse;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.validation.BindingResult;import org.springframework.validation.ObjectError;import org.springframework.web.bind.MethodArgumentNotValidException;import org.springframework.web.bind.annotation.ControllerAdvice;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.bind.annotation.ResponseBody;import java.util.ArrayList;import java.util.List;//使用该注解代表开启了全局异常捕获@ControllerAdvicepublic class GlobalExceptionHandler &#123;    private final Logger log = LoggerFactory.getLogger(GlobalExceptionHandler.class);    //处理默认异常    @ExceptionHandler(Exception.class)    @ResponseBody    public Object handleException(Exception e)&#123;    log.error(&quot;Default Exception:&quot; ,e);        return ApiRestResponse.error(LiveMallExceptionEnum.SYSTEM_ERROR);    &#125;        //处理业务相关的自定义异常    @ExceptionHandler(LiveMallException.class)    @ResponseBody    public Object handleLiveMallException(LiveMallException e)&#123;        log.error(&quot;LiveMallException:&quot; ,e);        return ApiRestResponse.error(e.getCode(),e.getMessage());    &#125;        //处理参数校验异常    @ExceptionHandler(MethodArgumentNotValidException.class)    @ResponseBody    public ApiRestResponse handleMethodArgumentNotValidException(MethodArgumentNotValidException e)&#123;        log.error(&quot;MethodArgumentNotValidException:&quot;+e);        return handleBindingResult(e.getBindingResult());    &#125;        //把异常处理为对外暴露的提示    private ApiRestResponse handleBindingResult(BindingResult result)&#123;         List&lt;String&gt; list =new ArrayList&lt;&gt;();        if (result.hasErrors()) &#123;            List&lt;ObjectError&gt; allErrors = result.getAllErrors();            for (int i = 0; i &lt; allErrors.size(); i++) &#123;                ObjectError objectError = allErrors.get(i);                String defaultMessage = objectError.getDefaultMessage();                list.add(defaultMessage);            &#125;        &#125;        if (list.size()==0)&#123;            return ApiRestResponse.error(LiveMallExceptionEnum.REQUEST_PARAM_ERROR);        &#125;        return ApiRestResponse.error(LiveMallExceptionEnum.REQUEST_PARAM_ERROR.getCode(),list.toString());    &#125;&#125;\n\n\n如上图代码可知，需要处理的异常分为默认异常、业务相关的异常和参数校验相关异常。在本项目中，业务相关的异常是LiveMallException异常（继承自RuntimeException），成员变量为状态码和状态信息：\n\npackage com.shu.mall.exception;//业务相关异常public class LiveMallException extends RuntimeException&#123;        private final Integer code;    private final String message;    public LiveMallException(Integer code, String message) &#123;        this.code = code;        this.message = message;    &#125;    public LiveMallException(String message, Integer code, String message1) &#123;        super(message);        this.code = code;        this.message = message1;    &#125;    public LiveMallException(String message, Throwable cause, Integer code, String message1) &#123;        super(message, cause);        this.code = code;        this.message = message1;    &#125;    public LiveMallException(Throwable cause, Integer code, String message) &#123;        super(cause);        this.code = code;        this.message = message;    &#125;    public LiveMallException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace, Integer code, String message1) &#123;        super(message, cause, enableSuppression, writableStackTrace);        this.code = code;        this.message = message1;    &#125;        public LiveMallException(LiveMallExceptionEnum exceptionEnum)&#123;        this(exceptionEnum.getCode(),exceptionEnum.getMsg());    &#125;    public Integer getCode() &#123;        return code;    &#125;    @Override    public String getMessage() &#123;        return message;    &#125;&#125;\n\n\n\n\n在异常处理中，使用到了自定义枚举。这个主要是在controller层写具体控制器的时候，作为统一返回对象的方法参数使用。\n\npublic static &lt;T&gt; ApiRestResponse&lt;Object&gt; error(LiveMallExceptionEnum ex)&#123;        return new ApiRestResponse&lt;&gt;(ex.getCode(),ex.getMsg());    &#125;\n\n\n\npackage com.shu.mall.exception;//异常枚举public enum LiveMallExceptionEnum &#123;        NEED_UESR_NAME(10001,&quot;用户名不能为空&quot;),    NEED_PASSWORD(10002,&quot;密码不能为空&quot;),    PASSWORD_TOO_SHORT(10003,&quot;密码太短&quot;),    NAME_EXISTED(10004,&quot;不允许重名&quot;),    INSERT_FAILED(10005,&quot;插入失败，请重试&quot;),    WRONG_PASSWORD(10006,&quot;密码错误&quot;),    NEED_LOGIN(10007,&quot;用户未登录&quot;),    UPDATE_FAILED(10008,&quot;更新失败&quot;),    NEED_ADMIN(10009,&quot;无管理员权限&quot;),    PARA_NOT_NULL(10010,&quot;名字不能为空&quot;),    CREATE_FAILED(10011,&quot;创建失败&quot;),    REQUEST_PARAM_ERROR(10012,&quot;请求参数失败&quot;),    DELETE_FAILED(10013,&quot;删除失败&quot;),    MKDIR_FAILED(10014,&quot;文件夹创建失败&quot;),    UPLOAD_FAILED(10015,&quot;上传失败&quot;),    NOT_SALE(10016, &quot;商品状态不可售&quot;),    NOT_ENOUGH(10017, &quot;商品库存不足&quot;),    CART_EMPTY(10018, &quot;购物车已勾选的商品为空&quot;),    NO_ENUM(10019, &quot;未找到对应的枚举&quot;),    NO_ORDER(10020, &quot;订单不存在&quot;),    NOT_YOUR_ORDER(10021, &quot;订单不属于你&quot;),    WRONG_ORDER_STATUS(10022, &quot;订单状态不符&quot;),    SYSTEM_ERROR(20000,&quot;系统错误&quot;);    Integer code;    String msg;        LiveMallExceptionEnum(Integer code, String msg) &#123;        this.code = code;        this.msg = msg;    &#125;    public Integer getCode() &#123;        return code;    &#125;        public void setCode(Integer code) &#123;        this.code = code;    &#125;    public String getMsg() &#123;        return msg;    &#125;    public void setMsg(String msg) &#123;        this.msg = msg;    &#125;    @Override    public String toString() &#123;        return &quot;LiveMallExceptionEnum&#123;&quot; +                &quot;code=&quot; + code +                &quot;, msg=&#x27;&quot; + msg + &#x27;\\&#x27;&#x27; +                &#x27;&#125;&#x27;;    &#125;&#125;\n\n\n\n2、参数校验\n如果不用参数校验，原始的就是if语句，那就太傻了…..\n我们不傻，我们在请求类中用valid参数校验\n\npackage com.shu.mall.model.request;import javax.validation.constraints.Max;import javax.validation.constraints.NotNull;import javax.validation.constraints.Size;//添加目录的请求类public class AddCategoryReq &#123;    @Size(min =2,max=5)    @NotNull(message = &quot;name:不能为null&quot;)    private String name;    @Max(3)    @NotNull(message = &quot;type:不能为null&quot;)    private Integer type;    @NotNull(message = &quot;parentId:不能为null&quot;)    private Integer parentId;    @NotNull(message = &quot;orderNum:不能为null&quot;)    private Integer orderNum;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public Integer getType() &#123;        return type;    &#125;    public void setType(Integer type) &#123;        this.type = type;    &#125;    public Integer getParentId() &#123;        return parentId;    &#125;    public void setParentId(Integer parentId) &#123;        this.parentId = parentId;    &#125;    public Integer getOrderNum() &#123;        return orderNum;    &#125;    public void setOrderNum(Integer orderNum) &#123;        this.orderNum = orderNum;    &#125;    @Override    public String toString() &#123;        return &quot;AddCategoryReq&#123;&quot; +                &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +                &quot;, type=&quot; + type +                &quot;, parentId=&quot; + parentId +                &quot;, orderNum=&quot; + orderNum +                &#x27;&#125;&#x27;;    &#125;&#125;\n\n\n\n3、统一响应package com.shu.mall.common;import com.shu.mall.exception.LiveMallExceptionEnum;//返回通用接口public class ApiRestResponse&lt;T&gt; &#123;    //状态码    private Integer status;    //信息    private String msg;    //泛型，数据类型不固定，表示数据    private T data;    private static final int OK_CODE = 10000;    private static final String OK_MSG = &quot;SUCCESS&quot;;    public Integer getStatus() &#123;        return status;    &#125;    public void setStatus(Integer status) &#123;        this.status = status;    &#125;    public String getMsg() &#123;        return msg;    &#125;    public void setMsg(String msg) &#123;        this.msg = msg;    &#125;    public T getData() &#123;        return data;    &#125;    public void setData(T data) &#123;        this.data = data;    &#125;    public static int getOkCode() &#123;        return OK_CODE;    &#125;    public static String getOkMsg() &#123;        return OK_MSG;    &#125;    public ApiRestResponse(Integer status, String msg, T data) &#123;        this.status = status;        this.msg = msg;        this.data = data;    &#125;    public ApiRestResponse(Integer status, String msg) &#123;        this.status = status;        this.msg = msg;    &#125;    public ApiRestResponse() &#123;        this(OK_CODE,OK_MSG);    &#125;    public static &lt;T&gt; ApiRestResponse&lt;T&gt; success()&#123;        return new ApiRestResponse&lt;&gt;();    &#125;    public static &lt;T&gt; ApiRestResponse&lt;Object&gt; success(T result)&#123;        ApiRestResponse&lt;Object&gt; response = new ApiRestResponse&lt;&gt;();        response.setData(result);        return response;    &#125;    public static &lt;T&gt; ApiRestResponse&lt;Object&gt; error(Integer code ,String msg)&#123;        return new ApiRestResponse&lt;&gt;(code,msg);    &#125;    public static &lt;T&gt; ApiRestResponse&lt;Object&gt; error(LiveMallExceptionEnum ex)&#123;        return new ApiRestResponse&lt;&gt;(ex.getCode(),ex.getMsg());    &#125;&#125;\n\n4、Redis缓存的使用\n首先，在pom.xml文件中添加依赖\n\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;&lt;/dependency&gt;\n\n\n然后，在启动类中使用@EnableCaching注解启动缓存\n\npackage com.shu.mall;import org.mybatis.spring.annotation.MapperScan;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cache.annotation.EnableCaching;import springfox.documentation.swagger2.annotations.EnableSwagger2;/** * @author 严树成 */@SpringBootApplication@MapperScan(basePackages = &quot;com.shu.mall.model.dao&quot;)@EnableSwagger2@EnableCachingpublic class MallApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(MallApplication.class, args);    &#125;&#125;\n\n\n然后，在application.properties中配置Redis的主机号和端口号（注意，记住端口号6379！）\n\nspring.redis.host=localhostspring.redis.port=6379\n\n\n然后，配置CacheManager,设置缓存持续时间为30s\n\npackage com.shu.mall.config;import org.springframework.cache.annotation.EnableCaching;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.cache.RedisCacheConfiguration;import org.springframework.data.redis.cache.RedisCacheManager;import org.springframework.data.redis.cache.RedisCacheWriter;import org.springframework.data.redis.connection.RedisConnectionFactory;import java.time.Duration;@Configuration@EnableCachingpublic class CachingConfig &#123;    @Bean    public RedisCacheManager redisCacheManager(RedisConnectionFactory connectionFactory)&#123;        RedisCacheWriter redisCacheWriter = RedisCacheWriter                .lockingRedisCacheWriter(connectionFactory);        RedisCacheConfiguration cacheConfiguration = RedisCacheConfiguration.defaultCacheConfig();        cacheConfiguration = cacheConfiguration.entryTtl(Duration.ofSeconds(30));        RedisCacheManager redisCacheManager = new RedisCacheManager(redisCacheWriter,                cacheConfiguration);        return redisCacheManager;    &#125;&#125;\n\n\n使用Redis，在service层的实现类中，在面向用户的商品列表查询的接口实现中添加**@Cacheable注解**\n\n@Override    @Cacheable(value = &quot;listCategoryForCustomer&quot;)    public List&lt;CategoryVo&gt; listCategoryForCustomer(Integer parentId)&#123;        ArrayList&lt;CategoryVo&gt; categoryVoList = new ArrayList&lt;&gt;();        recursivelyFindCategories(categoryVoList,0);        return categoryVoList;    &#125;\n\n5、SpringBoot整合MyBatis配置\n首先，pom.xml的依赖\n\n&lt;dependency&gt;          &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;          &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;          &lt;version&gt;1.3.2&lt;/version&gt;      &lt;/dependency&gt;      &lt;dependency&gt;          &lt;groupId&gt;mysql&lt;/groupId&gt;          &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;      &lt;/dependency&gt;\n\n\napplication.properties配置（数据库驱动、用户名和密码、url、端口号、mapper文件所在路径）\n\nspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.username=rootspring.datasource.password=ysc223spring.datasource.url=jdbc:mysql://localhost:3306/imooc_mall?useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false&amp;serverTimezone=GMTserver.port=8083mybatis.mapper-locations=classpath:mappers/*.xml\n\n\nmapper映射（dao层Mapper接口–&gt;Mapper.xml文件）\n\npackage com.shu.mall.model.dao;import com.shu.mall.model.pojo.User;import org.apache.ibatis.annotations.Param;import org.springframework.stereotype.Repository;/** * @author 严树成 * @describe 用户接口。包含增删改查用户信息的抽象方法。 */@Repositorypublic interface UserMapper &#123;    /**     * @describe 根据主键删除用户     * @param id ，Integer类型     * @return     */    int deleteByPrimaryKey(Integer id);    /**     * @describe 插入用户     * @param record ，User类型     * @return     */    int insert(User record);    /**     * @describe 选择性的插入用户     * @param record     * @return     */    int insertSelective(User record);    /**     * @describe 根据主键查询     * @param id     * @return 用户 User类型     */    User selectByPrimaryKey(Integer id);    /**     * @describe 根据主键选择的更新     * @param record     * @return     */    int updateByPrimaryKeySelective(User record);    /**     * @describe 通过主键更新     * @param record     * @return     */    int updateByPrimaryKey(User record);    /**     * @param userName     * @return     */    User selectByName(String userName);    User selectLogin(@Param(&quot;userName&quot;) String userName, @Param(&quot;password&quot;) String password);&#125;\n\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.shu.mall.model.dao.UserMapper&quot;&gt;  &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.shu.mall.model.pojo.User&quot;&gt;    &lt;id column=&quot;id&quot; jdbcType=&quot;INTEGER&quot; property=&quot;id&quot; /&gt;    &lt;result column=&quot;username&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;username&quot; /&gt;    &lt;result column=&quot;password&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;password&quot; /&gt;    &lt;result column=&quot;personalized_signature&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;personalizedSignature&quot; /&gt;    &lt;result column=&quot;role&quot; jdbcType=&quot;INTEGER&quot; property=&quot;role&quot; /&gt;    &lt;result column=&quot;create_time&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;createTime&quot; /&gt;    &lt;result column=&quot;update_time&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;updateTime&quot; /&gt;  &lt;/resultMap&gt;  &lt;sql id=&quot;Base_Column_List&quot;&gt;    id, username, `password`, personalized_signature, `role`, create_time, update_time  &lt;/sql&gt;  &lt;select id=&quot;selectByPrimaryKey&quot; parameterType=&quot;java.lang.Integer&quot; resultMap=&quot;BaseResultMap&quot;&gt;    select     &lt;include refid=&quot;Base_Column_List&quot; /&gt;    from imooc_mall_user    where id = #&#123;id,jdbcType=INTEGER&#125;  &lt;/select&gt;  &lt;delete id=&quot;deleteByPrimaryKey&quot; parameterType=&quot;java.lang.Integer&quot;&gt;    delete from imooc_mall_user    where id = #&#123;id,jdbcType=INTEGER&#125;  &lt;/delete&gt;  &lt;insert id=&quot;insert&quot; parameterType=&quot;com.shu.mall.model.pojo.User&quot;&gt;    insert into imooc_mall_user (id, username, `password`,       personalized_signature, `role`, create_time,       update_time)    values (#&#123;id,jdbcType=INTEGER&#125;, #&#123;username,jdbcType=VARCHAR&#125;, #&#123;password,jdbcType=VARCHAR&#125;,       #&#123;personalizedSignature,jdbcType=VARCHAR&#125;, #&#123;role,jdbcType=INTEGER&#125;, #&#123;createTime,jdbcType=TIMESTAMP&#125;,       #&#123;updateTime,jdbcType=TIMESTAMP&#125;)  &lt;/insert&gt;  &lt;insert id=&quot;insertSelective&quot; parameterType=&quot;com.shu.mall.model.pojo.User&quot;&gt;    insert into imooc_mall_user    &lt;trim prefix=&quot;(&quot; suffix=&quot;)&quot; suffixOverrides=&quot;,&quot;&gt;      &lt;if test=&quot;id != null&quot;&gt;        id,      &lt;/if&gt;      &lt;if test=&quot;username != null&quot;&gt;        username,      &lt;/if&gt;      &lt;if test=&quot;password != null&quot;&gt;        `password`,      &lt;/if&gt;      &lt;if test=&quot;personalizedSignature != null&quot;&gt;        personalized_signature,      &lt;/if&gt;      &lt;if test=&quot;role != null&quot;&gt;        `role`,      &lt;/if&gt;      &lt;if test=&quot;createTime != null&quot;&gt;        create_time,      &lt;/if&gt;      &lt;if test=&quot;updateTime != null&quot;&gt;        update_time,      &lt;/if&gt;    &lt;/trim&gt;    &lt;trim prefix=&quot;values (&quot; suffix=&quot;)&quot; suffixOverrides=&quot;,&quot;&gt;      &lt;if test=&quot;id != null&quot;&gt;        #&#123;id,jdbcType=INTEGER&#125;,      &lt;/if&gt;      &lt;if test=&quot;username != null&quot;&gt;        #&#123;username,jdbcType=VARCHAR&#125;,      &lt;/if&gt;      &lt;if test=&quot;password != null&quot;&gt;        #&#123;password,jdbcType=VARCHAR&#125;,      &lt;/if&gt;      &lt;if test=&quot;personalizedSignature != null&quot;&gt;        #&#123;personalizedSignature,jdbcType=VARCHAR&#125;,      &lt;/if&gt;      &lt;if test=&quot;role != null&quot;&gt;        #&#123;role,jdbcType=INTEGER&#125;,      &lt;/if&gt;      &lt;if test=&quot;createTime != null&quot;&gt;        #&#123;createTime,jdbcType=TIMESTAMP&#125;,      &lt;/if&gt;      &lt;if test=&quot;updateTime != null&quot;&gt;        #&#123;updateTime,jdbcType=TIMESTAMP&#125;,      &lt;/if&gt;    &lt;/trim&gt;  &lt;/insert&gt;  &lt;update id=&quot;updateByPrimaryKeySelective&quot; parameterType=&quot;com.shu.mall.model.pojo.User&quot;&gt;    update imooc_mall_user    &lt;set&gt;      &lt;if test=&quot;username != null&quot;&gt;        username = #&#123;username,jdbcType=VARCHAR&#125;,      &lt;/if&gt;      &lt;if test=&quot;password != null&quot;&gt;        `password` = #&#123;password,jdbcType=VARCHAR&#125;,      &lt;/if&gt;      &lt;if test=&quot;personalizedSignature != null&quot;&gt;        personalized_signature = #&#123;personalizedSignature,jdbcType=VARCHAR&#125;,      &lt;/if&gt;      &lt;if test=&quot;role != null&quot;&gt;        `role` = #&#123;role,jdbcType=INTEGER&#125;,      &lt;/if&gt;      &lt;if test=&quot;createTime != null&quot;&gt;        create_time = #&#123;createTime,jdbcType=TIMESTAMP&#125;,      &lt;/if&gt;      &lt;if test=&quot;updateTime != null&quot;&gt;        update_time = #&#123;updateTime,jdbcType=TIMESTAMP&#125;,      &lt;/if&gt;    &lt;/set&gt;    where id = #&#123;id,jdbcType=INTEGER&#125;  &lt;/update&gt;  &lt;update id=&quot;updateByPrimaryKey&quot; parameterType=&quot;com.shu.mall.model.pojo.User&quot;&gt;    update imooc_mall_user    set username = #&#123;username,jdbcType=VARCHAR&#125;,      `password` = #&#123;password,jdbcType=VARCHAR&#125;,      personalized_signature = #&#123;personalizedSignature,jdbcType=VARCHAR&#125;,      `role` = #&#123;role,jdbcType=INTEGER&#125;,      create_time = #&#123;createTime,jdbcType=TIMESTAMP&#125;,      update_time = #&#123;updateTime,jdbcType=TIMESTAMP&#125;    where id = #&#123;id,jdbcType=INTEGER&#125;  &lt;/update&gt;  &lt;select id=&quot;selectByName&quot; parameterType=&quot;java.lang.String&quot;          resultMap=&quot;BaseResultMap&quot;&gt;            select            &lt;include refid=&quot;Base_Column_List&quot;/&gt;              from imooc_mall_user              where username =#&#123;userName,jdbcType=VARCHAR&#125;  &lt;/select&gt;  &lt;select id=&quot;selectLogin&quot; parameterType=&quot;map&quot;          resultMap=&quot;BaseResultMap&quot;&gt;    select    &lt;include refid=&quot;Base_Column_List&quot;/&gt;    from imooc_mall_user    where username =#&#123;userName,jdbcType=VARCHAR&#125;    and password=#&#123;password&#125;  &lt;/select&gt;&lt;/mapper&gt;\n\n6、使用AOP统一处理Web请求日志（面向切面编程和日志,在项目中也属于过滤器的一部分）\n首先，在pom.xml导入web模块\n\n&lt;dependency&gt;          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;          &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;          &lt;exclusions&gt;              &lt;exclusion&gt;                  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                  &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;              &lt;/exclusion&gt;          &lt;/exclusions&gt;      &lt;/dependency&gt;\n\n\n引入AOP依赖和log4j2日志依赖\n\n&lt;dependency&gt;          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;          &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt;      &lt;/dependency&gt;      &lt;dependency&gt;          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;          &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;      &lt;/dependency&gt;\n\n\n实现Web层面的日志切面\n使用@Aspect注解将一个java类定义为切面类\n使用@Pointcut定义一个切入点，可以是一个规则表达式，比如下例中某个package下的所有函数，也可以是一个注解等。\n使用@Before在切入点开始处切入内容\n使用@After在切入点结尾处切入内容\n使用@AfterReturning在切入点return内容之后切入内容（可以用来对处理返回值做一些加工处理）\n\n\npackage com.shu.mall.filter;import com.fasterxml.jackson.core.JsonProcessingException;import com.fasterxml.jackson.databind.ObjectMapper;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.annotation.AfterReturning;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.aspectj.lang.annotation.Pointcut;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.stereotype.Component;import org.springframework.web.context.request.RequestContextHolder;import org.springframework.web.context.request.ServletRequestAttributes;import javax.servlet.http.HttpServletRequest;import java.util.Arrays;@Aspect@Componentpublic class WebLogAspect &#123;    private final Logger log = LoggerFactory.getLogger(WebLogAspect.class);    @Pointcut(&quot;execution(public * com.shu.mall.controller.*.*(..))&quot;)    public void webLog() &#123;    &#125;    @Before(&quot;webLog()&quot;)    public void doBefore(JoinPoint joinPoint) &#123;        //收到请求，记录请求记录        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();        HttpServletRequest request = attributes.getRequest();        log.info(&quot;URL:&quot; + request.getRequestURL().toString());        log.info(&quot;HTTP_METHOD:&quot; + request.getMethod());        log.info(&quot;IP:&quot; + request.getRemoteAddr());        log.info(&quot;CLASS_METHOD:&quot; + joinPoint.getSignature().getDeclaringTypeName() + &quot;.&quot; + joinPoint.getSignature().getName());        log.info(&quot;ARGS:&quot; + Arrays.toString(joinPoint.getArgs()));    &#125;    @AfterReturning(returning = &quot;res&quot;, pointcut = &quot;webLog()&quot;)    public void doAfterReturning(Object res) throws JsonProcessingException &#123;        //处理完请求，返回内容        log.info(&quot;RESPONSE:&quot; + new ObjectMapper().writeValueAsString(res));    &#125;&#125;\n\n7、用户控制器（Session、登录状态判断、权限管理、过滤器）\n面向用户的如下，主要判断是否处于登录状态\n\npackage com.shu.mall.filter;import com.shu.mall.common.Constant;import com.shu.mall.model.pojo.User;import com.shu.mall.service.UserService;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.Filter;import javax.servlet.FilterChain;import javax.servlet.FilterConfig;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpServletResponseWrapper;import javax.servlet.http.HttpSession;import org.springframework.beans.factory.annotation.Autowired;/** * 描述：     用户过滤器 */public class UserFilter implements Filter &#123;    public static User currentUser;    @Autowired    UserService userService;    @Override    public void init(FilterConfig filterConfig) throws ServletException &#123;    &#125;    @Override    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse,            FilterChain filterChain) throws IOException, ServletException &#123;        HttpServletRequest request = (HttpServletRequest) servletRequest;        HttpSession session = request.getSession();        currentUser = (User) session.getAttribute(Constant.LIVE_MALL_USER);        if (currentUser == null) &#123;            PrintWriter out = new HttpServletResponseWrapper(                    (HttpServletResponse) servletResponse).getWriter();            out.write(&quot;&#123;\\n&quot;                    + &quot;    \\&quot;status\\&quot;: 10007,\\n&quot;                    + &quot;    \\&quot;msg\\&quot;: \\&quot;NEED_LOGIN\\&quot;,\\n&quot;                    + &quot;    \\&quot;data\\&quot;: null\\n&quot;                    + &quot;&#125;&quot;);            out.flush();            out.close();            return;        &#125;        filterChain.doFilter(servletRequest, servletResponse);    &#125;    @Override    public void destroy() &#123;    &#125;&#125;\n\n\n\n\n面向管理员的如下，主要判断是否处于登录状态以及是否是管理员权限\npackage com.shu.mall.filter;import com.shu.mall.common.Constant;import com.shu.mall.model.pojo.User;import com.shu.mall.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import javax.servlet.*;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpServletResponseWrapper;import javax.servlet.http.HttpSession;import java.io.IOException;import java.io.PrintWriter;//统一校验处理public class AdminFilter implements Filter &#123;    @Autowired    UserService userService;    @Override    public void init(FilterConfig filterConfig) throws ServletException &#123;    &#125;    @Override    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;        HttpServletRequest request1 = (HttpServletRequest) request;        HttpSession session = request1.getSession();        User currentUser = (User) session.getAttribute(Constant.LIVE_MALL_USER);        if (currentUser == null) &#123;            PrintWriter out = new HttpServletResponseWrapper((HttpServletResponse) response).getWriter();            out.write(&quot;&#123;\\n&quot;                    + &quot;    \\&quot;status\\&quot;: 10007,\\n&quot;                    + &quot;    \\&quot;msg\\&quot;: \\&quot;NEED_LOGIN\\&quot;,\\n&quot;                    + &quot;    \\&quot;data\\&quot;: null\\n&quot;                    + &quot;&#125;&quot;);            out.flush();            out.close();            return;        &#125;        //校验当前登录用户是否管理员        if (currentUser.getRole() == 2) &#123;            chain.doFilter(request,response);        &#125; else &#123;            PrintWriter out = new HttpServletResponseWrapper((HttpServletResponse) response).getWriter();            out.write(&quot;&#123;\\n&quot;                    + &quot;    \\&quot;status\\&quot;: 10009,\\n&quot;                    + &quot;    \\&quot;msg\\&quot;: \\&quot;NEED_ADMIN\\&quot;,\\n&quot;                    + &quot;    \\&quot;data\\&quot;: null\\n&quot;                    + &quot;&#125;&quot;);            out.flush();            out.close();        &#125;    &#125;    @Override    public void destroy() &#123;    &#125;&#125;\n\n8、PageInfo分页处理\n首先，导入pagehelper依赖\n\n&lt;dependency&gt;          &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;          &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;          &lt;version&gt;1.2.13&lt;/version&gt;      &lt;/dependency&gt;\n\n2. 然后初始化分页参数、查询结果、对查询结果进行分页\n\npackage com.shu.mall.service.impl;import com.github.pagehelper.PageHelper;import com.github.pagehelper.PageInfo; @Override    public PageInfo listforAdmin(Integer pageNum, Integer pageSize)&#123;        PageHelper.startPage(pageNum,pageSize);        List&lt;Product&gt; products = productMapper.selectListForAdmin();        PageInfo pageInfo = new PageInfo(products);        return pageInfo;\n\n\n面向用户的商品列表返回，涉及搜索处理、目录处理、排序处理。Query对象中默认设置pageNum=1，pageSize=10\n\n@Override    public PageInfo list(ProductListReq productListReq) &#123;        //构建Query对象        ProductListQuery productListQuery = new ProductListQuery();        //搜索处理        if (!StringUtils.isEmpty(productListReq.getKeyword())) &#123;            String keyword = new StringBuilder().append(&quot;%&quot;).append(productListReq.getKeyword())                    .append(&quot;%&quot;).toString();            productListQuery.setKeyword(keyword);        &#125;        //目录处理：如果查某个目录下的商品，不仅是需要查出该目录下的，还要把所有子目录的所有商品都查出来，所以要拿到一个目录id的List        if (productListReq.getCategoryId() != null) &#123;            List&lt;CategoryVo&gt; categoryVoList = categoryService                    .listCategoryForCustomer(productListReq.getCategoryId());            ArrayList&lt;Integer&gt; categoryIds = new ArrayList&lt;&gt;();            categoryIds.add(productListReq.getCategoryId());            getCategoryIds(categoryVoList, categoryIds);            productListQuery.setCategoryIds(categoryIds);        &#125;        //排序处理        String orderBy = productListReq.getOrderBy();        if (Constant.ProductListOrderBy.PRICE_ASC_DESC.contains(orderBy)) &#123;            PageHelper.startPage(productListReq.getPageNum(), productListReq.getPageSize(), orderBy);        &#125; else &#123;            PageHelper.startPage(productListReq.getPageNum(), productListReq.getPageSize());        &#125;        List&lt;Product&gt; productList = productMapper.selectList(productListQuery);        PageInfo pageInfo = new PageInfo(productList);        return pageInfo;    &#125;    private void getCategoryIds(List&lt;CategoryVo&gt; categoryVoList, ArrayList&lt;Integer&gt; categoryIds) &#123;        for (int i = 0; i &lt; categoryVoList.size(); i++) &#123;            CategoryVo categoryVo = categoryVoList.get(i);            if (categoryVo != null) &#123;                categoryIds.add(categoryVo.getId());                getCategoryIds(categoryVo.getChildCategory(), categoryIds);            &#125;        &#125;    &#125;\n\n9、事务管理订单模块\n触发回滚的异常设置为Exception.class，MySQL的默认事务隔离级别是可重复读\n\n@Transactional(rollbackFor = Exception.class)@Overridepublic String create(CreateOrderReq createOrderReq)&#123;    //拿到用户ID    Integer userId = UserFilter.currentUser.getId();    //从购物车查找已经勾选的商品    List&lt;CartVO&gt; cartVOList = cartService.list(userId);    ArrayList&lt;CartVO&gt; cartVOTemp = new ArrayList&lt;&gt;();    for (int i = 0; i &lt; cartVOList.size(); i++) &#123;        CartVO cartVO = cartVOList.get(i);        if (cartVO.getSelected().equals(Constant.Cart.CHECKED)) &#123;            cartVOTemp.add(cartVO);        &#125;    &#125;    cartVOList = cartVOTemp;    //如果购物车已勾选的为空，报错    if (CollectionUtils.isEmpty(cartVOList)) &#123;        throw new LiveMallException(LiveMallExceptionEnum.CART_EMPTY);    &#125;    //判断商品是否存在、上下架状态、库存    validSaleStatusAndStock(cartVOList);    //把购物车对象转化成订单item对象    List&lt;OrderItem&gt; orderItemList = cartVOListToOrderItemList(cartVOList);    //扣库存    for (int i = 0; i &lt; orderItemList.size(); i++) &#123;        Product product = productMapper.selectByPrimaryKey(orderItemList.get(i).getProductId());        Integer stock = product.getStock();        stock=stock-orderItemList.get(i).getQuantity();        if (stock&lt;0)&#123;            throw new LiveMallException(LiveMallExceptionEnum.NOT_ENOUGH);        &#125;        product.setStock(stock);        productMapper.updateByPrimaryKeySelective(product);    &#125;    //把购物车中的已勾选商品删除    cleanCart(cartVOList);    //生成订单    Order order = new Order();    //生成订单号，有独立的规则    String orderNo = OrderCodeFactory.getOrderCode(Long.valueOf(userId));    order.setOrderNo(orderNo);    order.setUserId(userId);    order.setTotalPrice(totalPrice(orderItemList));    order.setReceiverName(createOrderReq.getReceiverName());    order.setReceiverMobile(createOrderReq.getReceiverMobile());    order.setReceiverAddress(createOrderReq.getReceiverAddress());    order.setOrderStatus(Constant.OrderStatusEnum.NOT_PAID.getCode());    order.setPostage(0);    order.setPaymentType(1);    //插入到order表    orderMapper.insertSelective(order);    //循环保存每个商品到order_item表    for (int i = 0; i &lt; orderItemList.size(); i++) &#123;        OrderItem orderItem = orderItemList.get(i);        orderItem.setOrderNo(order.getOrderNo());        orderItemMapper.insertSelective(orderItem);    &#125;    //把结果返回    return orderNo;&#125;\n\n","categories":[],"tags":[]},{"title":"鼓楼|歌词","url":"https://sacharn.github.io/2021/03/22/鼓楼-歌词/","content":"我走在鼓楼下面\n路在堵着\n雨后的阳光散落\n人们都出来了\n执着的迷惘的\n文艺青年很多\n如果我无聊了就会来这里坐坐\n我是个沉默不语的靠着墙壁晒太阳的过客\n如果我有些倦意了\n就让我在这里独自醒过\n我站在鼓楼上面\n一切繁华与我无关\n这是个拥挤的地方\n而我却很平凡\n我走在鼓楼下面\n淋湿的咖啡馆\n睡不着的后海边\n月亮还在抽着烟\n喝醉的亲吻着\n快活的人不眠\n唯有我倚着围栏\n对过往说晚安\n晚安\n我是个沉默不语的靠着车窗想念你的乘客\n当一零七路再次经过\n时间是带走青春的电车\n我站在什刹海边\n一切甜蜜与我无关\n这是个拥挤的地方\n而我却很孤单\n我在鼓楼 我在鼓楼\n我在鼓楼 我在鼓楼\n我在鼓楼 我在鼓楼\n","categories":[],"tags":[]},{"title":"JVM知识问答总结","url":"https://sacharn.github.io/2021/03/21/JVM知识问答总结/","content":"1. JVM基础1.1 对JVM的认识和理解\n功能：JVM的全称是Java虚拟机，用来运行字节码文件（.class）。\n优点：它屏蔽了具体操作系统和平台的差异，使得同一字节码能在不同平台运行，且能得到相同的结果。\n\n1.1.1 什么是字节码\n定义：扩展名为 .class 的的文件叫做字节码，相比较于源码，它是程序的一种低级表示。\n特性：不面向特定的处理器，只面向虚拟机JVM，经过虚拟机处理过后，程序可以在多平台上运行。\n\n1.1.2 Java 程序从代码到运行的过程\n过程：编写 -&gt; 编译 -&gt; 解释\n⾸先通过IDE/编辑器编写源代码然后经过 JDK 中的编译器（javac）编译成 Java 字节码⽂件（.class⽂件），字节码通过虚拟机执⾏，虚拟机将每⼀条要执⾏的字节码送给解释器，解释器会将其翻译成特定机器上的机器码（及其可执⾏的⼆进制机器码）。\n\n1.2 对类加载器的了解\n功能：类加载器根据指定class文件的全限定名称（例如java.lang.Object，路径+文件的形式），将其加载到JVM内存，转化为Class对象\n\n1.2.1 类加载器的执行流程\n1.2.1.1 加载\n通过类的全限定名来获取该类的二进制字节流\n将二进制字节流所代表的静态存储结构导入为方法区的运行时数据结构\n在堆中生成一个对象来代表这个类，作为方法区数据的入口\n\n1.2.1.2 链接\n验证：保证二进制字节流符合虚拟机的要求，且不会威胁到虚拟机的安全。\n\n准备：为static静态变量分配内存，并设置初始值。\n\n解析：虚拟机将常量池中的符号引用转化为直接引用。\n例如 import xxx.xxx.xxx 属于符号引⽤，⽽通过指针或者对象地址引⽤就是直接引⽤\n\n\n1.2.1.3 初始化​    初始化会对变量进⾏赋值，即对最初的零值，进⾏显式初始化\n1.2.1.4 卸载​    GC 垃圾回收内存中的⽆⽤对象\n1.2.2 类加载器有哪几种，加载顺序是什么样的\n启动类加载器：JDK目录/lib下的jar和类以及**-Xbootclasspath参数指定路径下**的所有类\n\n扩展类加载器：JRE⽬录/lib 下⾯的 jar 和类以及java.ext.dirs 系统变量所指定的路径下的 jar 包\n\n应用类加载器：当前应⽤下 classpath 下⾯的 jar 包和类\n顺序：最底层向上\n\n\n1.2.3 双亲委派机制\n⼯作过程是：如果⼀个类加载器收到了类加载的请求，他⾸先不会⾃⼰去尝试加载这个类，⽽是把这个请求委派给⽗类加载器去完成，每⼀个层次的类加载都是如此，因此所有的加载请求都最终应该传送到最顶层的启动类加载器中，只有当⽗加载器反馈⾃⼰⽆法完成这个加载请求（也就是它的范围搜索中，也没有找到所需要的类），⼦加载器才会尝试⾃⼰去完成加载。\n\n优点：\n\n加载位于rt.jar包中的类（例如 java.lang.Object）时不管是哪个加载器加载，最终都会委托最顶端的启动类加载器 BootStrapClassLoader 进⾏加载，这样保证它在各个类加载器环境下都是同⼀个结果。\n避免了⾃定义代码影响 JDK 的代码，如果我们⾃⼰也创建了⼀个 java.lang.Object 然后放在程序的 classpath 中，就会导致系统中出现不同的 Object 类，Java 类型体系中最基础的⾏为也就⽆法保证。\n\n\n不想用双亲委派机制怎么没办\n自定义类加载器，然后重写loadClass()方法\n\n\n","categories":[],"tags":[]},{"title":"MySQL是如何实现事务隔离的","url":"https://sacharn.github.io/2021/03/21/MySQL是如何实现事务隔离的/","content":"\n首先，读未提交和串行化都是比较极端的做法，读未提交压根不加锁，所以也没有什么隔离效果，可以理解为无隔离。\n其次，串行化。读的时候加共享锁，大家一起读。但是写的时候加排它锁，其他事务既不能并发写，也不能并发读。\n最后是读提交和可重复读。这两种隔离级别比较复杂，因为既要允许一定程度的并发，也要兼顾解决问题。\n\n实现可重复读为了解决不可重复读，或者为了实现可重复读，MySQL 采⽤了 MVVC (多版本并发控制) 的⽅式。\n！可重复读\n我们在数据库表中看到的⼀⾏记录可能实际上有多个版本，每个版本的记录除了有数据本⾝外，还要有⼀个表示版本的字段，记为 row trx_id，⽽这个字段就是使其产⽣的事务的 id，事务 ID 记为 transaction id，它在事务开始的时候向事务系统申请，按时间先后顺序递增。\n\n快照是可重复读和不可重复读的关键，可重复读是在事务开始的时候⽣成⼀个当前事务全局性的快照，⽽读提交则是每次执⾏语句的时候都重新⽣成⼀次快照。\n\n解决并发写问题\n假设事务A执⾏ update 操作， update 的时候要对所修改的行加行锁，这个⾏锁会在提交之后才释放。⽽在事务A提交之前，事务B也想 update 这⾏数据，于是申请⾏锁，但是由于已经被事务A占有，事务B是申请不到的，此时，事务B就会⼀直处于等待状态，直到事务A提交，事务B才能继续执⾏，如果事务A的时间太长，那么事务B很有可能出现超时异常。\n加锁的过程要分有索引和⽆索引两种情况，⽐如下⾯这条语句\n\nupdate user set age=11 where id = 1\n\n\nid 是这张表的主键，是有索引的情况，那么 MySQL 直接就在索引数中找到了这⾏数据，然后⼲净利落的直接加上⾏锁就可以了。\n\n⽽下⾯这条语句\nupdate user set age=11 where age=10\n\n\n表中并没有为 age 字段设置索引，所以， MySQL ⽆法直接定位到这⾏数据。那怎么办呢，当然也不是加表锁了。MySQL 会为这张表中所有⾏加⾏锁，没错，是所有⾏。但是呢，在加上⾏锁后，MySQL 会进⾏⼀遍过滤，发现不满⾜的⾏就释放锁，最终只留下符合条件的⾏。虽然最终只为符合条件的⾏加了锁，但是这⼀锁⼀释放的过程对性能也是影响极⼤的。所以，如果是⼤表的话，建议合理设计索引，如果真的出现这种情况，那很难保证并发度。\n\n解决幻读问题\nMySQL 已经在可重复读隔离级别下解决了幻读的问题。\n\n前⾯刚说了并发写问题的解决⽅式就是⾏锁，⽽解决幻读⽤的也是锁，叫做间隙锁，MySQL把⾏锁和间隙锁合并在⼀起，解决了并发写和幻读的问题，这个锁叫做 Next-Key锁。\n\n在行记录上加行锁，在行记录两边的区间加上间隙锁。\n！解决幻读问题的间隙锁\n\n\n在事务A提交之前，事务B的插⼊操作只能等待，这就是间隙锁起得作⽤。当事务A执⾏\nupdate user set name=&#x27;风筝2号’ where age = 10;\n\n 的时候，由于条件 here age = 10，数据库不仅在 age =10 的⾏上添加了⾏锁，⽽且在这条记录的两边，也就是(负⽆穷,10]、(10,30]这两个区间加了间隙锁，从⽽导致事务B插⼊操作⽆法完成，只能等待事务A提交。不仅插⼊ age = 10 的记录需要等待事务A提交，age&lt;10、10&lt;age&lt;30 的记录页⽆法完成，⽽⼤于等于30的记录则不受影响，这⾜以解决幻读问题了。这是有索引的情况，如果 age 不是索引列，那么数据库会为整个表加上间隙锁。所以，如果是没有索引的话，不管 age 是否⼤于等于30，都要等待事务A提交才可以成功插⼊。\n总结\nMySQL 的 InnoDB 引擎才⽀持事务，其中可重复读是默认的隔离级别。\n读未提交和串⾏化基本上是不需要考虑的隔离级别，前者不加锁限制，后者相当于单线程执⾏，效率太差。\n读提交解决了脏读问题，⾏锁解决了并发更新的问题。并且 MySQL 在可重复读级别解决了幻读问题，是通过⾏锁和间隙锁的组合 Next-Key 锁实现的。\n\n","categories":[],"tags":[]},{"title":"MySQL事务隔离级别原理","url":"https://sacharn.github.io/2021/03/20/MySQL事务隔离级别和实现原理/","content":"MySQL事务\nMySQL 事务都是指在 InnoDB 引擎下，因为MyISAM引擎是不支持事务的。\n数据库是指：一组数据操作，事务内的操作要么全部成功，要么全部失败。只要有一步失败，就要回滚所有操作。\n事务具有四个特性：ACID——原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）\n\n四大问题：什么是脏读、可重复读、不可重复读、幻读？\n脏读：读到了其他事务修改了但尚未提交的数据。这个事务的操作有可能发生回滚，那么就可能发生错误。\n可重复读：在一个事务内，从事务开始到事务结束，期间读到的同一批数据，始终是一致的。通常，针对数据更新（UPDATE）操作。\n不可重复读：在一个事务内，不同时刻读到的数据可能是不一致的。通常，针对数据更新（UPDATE）操作。\n幻读：幻读是针对插入（INSERT）操作来说的。假设事务A对某些⾏的内容作了更改，但是还未提交，此时事务B插⼊了与事务A更改前的记录相同的记录⾏，并且在事务A提交之前先提交了，⽽这时，在事务A中查询，会发现好像刚刚的更改对于某些数据未起作⽤，但其实是事务B刚插⼊进来的，让⽤户感觉很魔幻，感觉出现了幻觉，这就叫幻读。\n\n四大隔离级别：读未提交、读提交、可重复读、串行化\nMySQL的默认隔离级别是可重复读。\n\nMySQL 中执⾏事务：事务的执⾏过程如下，以 begin 或者 start transaction 开始，然后执⾏⼀系列操作，最后要执⾏ commit 操作，事务才算结束。当然，如果进⾏回滚操作(rollback)，事务也会结束。\n需要注意的是，begin 命令并不代表事务的开始，事务开始于 begin 命令之后的第⼀条语句执⾏的时候。例如下⾯⽰例中，\nselect * from xxx \n\n才是事务的开始。\nbegin; select * from xxx;  commit; -- 或者 rollback;\n\n\n\n1、读未提交MySQL 事务隔离其实是依靠锁来实现的，加锁自然会带来性能的损失。⽽读未提交隔离级别是不加锁的，所以它的性能是最好的，没有加锁、解锁带来的性能开销。但有利就有弊，这基本上就相当于裸奔啊，所以它连脏读的问题都没办法解决。\n读未提交，其实就是可以读到其他事务未提交的数据，但没有办法保证你读到的数据最终⼀定是提交后的数据，如果中间发⽣回滚，那就会出现脏数据问题，读未提交没办法解决脏数据问题。更别提可重复读和幻读了。\n2、读提交为了解决脏数据问题，就有了读提交隔离级别。读提交就是⼀个事务只能读到其他事务已经提交过的数据，也就是其他事务调⽤ commit 命令之后的数据。那脏数据问题迎刃而解了。\n但这也导致了⼀个问题，在同⼀事务中（事务B），事务的不同时刻，同样的查询条件，查询出来的记录内容是不⼀样的。事务A的提交影响了事务B的查询结果（事务A提交前数值为1，提交后数值为10），这就是不可重复读问题，也就是读提交隔离级别。\n3、可重复读为了解决不可重复读问题，就有了可重复读隔离级别。同时启动两个事务A、B，事务A修改某数据并提交，但是事务B并不受修改的影响，读取的仍然是事务A修改前的值。\n但这仍然存在一个问题，对于新插⼊的⾏记录，就没这么幸运了，幻读就这么产⽣了。\n其实，MySQL 的可重复读隔离级别其实解决了幻读问题\n4、串行化为了解决幻读问题，就有了串行化的隔离级别。串⾏化是4种事务隔离级别中隔离效果最好的，解决了脏读、可重复读、幻读的问题，但是效果最差，它将事务的执⾏变为顺序执⾏，与其他三个隔离级别相⽐，它就相当于单线程，后⼀个事务的执⾏必须等待前⼀个事务结束。\n\n\n","categories":[],"tags":[]},{"title":"流水的学生，铁打的修路","url":"https://sacharn.github.io/2021/03/20/流水的学生，铁打的修路/","content":"​    坊间传闻着一句话——“半年修一次，一次修半年”，说的就是学校永不停歇的修路工程。\n","categories":[],"tags":[]},{"title":"Hello World","url":"https://sacharn.github.io/2021/03/18/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","categories":[],"tags":[]}]